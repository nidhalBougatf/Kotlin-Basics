I.Basics

1. Hellow World example
//Kotlin
//file : Hello.kt

package intro

fun main()
{
	
	val name="kotlin"
	println("Hello, $name  !")

	val mystr = if (name = "kotlin") "Welcome" else " Wrong course !"
	println(" $mystr ")
}



No need for a class 
You no longer need to put everything inside a class
No need for arguments in main
You can insert a value inside a string literal by using a dollar sign and a variable name
You can assign the result of 'if' into a variable or return it from a function


fun myFN(): String
{
	println("Test ...")
	return "done"
}

fun main()
{
	println("first ${myFN()} ,   second ${myFN()}  ")
}

we can call a function inside the string template ${ yourfunction)()}

Result is :
Test ...
Test ...
First done, second done


2. Variables
val(comes from 'value') : for read only variables 
variables that are declared using val cannot be reassigned ( it corresponds to 'final varibale' in Java)
	val q:String ="test"
	println("$q")
	q="test2" // Error


var : mutable variable ( that can be modified)
	var  x=0
	x =4
	println(x)
	Result : 4

In Kotlin you can omit the types of variables and the compiler will infer the types for you

var string =1
string="abc" // error : because the variable string has an Int type , later we cannot assign a string to an Int


What about Object ?
 val person 
 it can be modified , because it has the same reference ( we are modifying the content )



Exmaple for lists


val mutableList = mutableListOf("Java")
mutableList.add("Kotlin")


val readOnlyList = listOf("Java2")
readOnlyList.add("Kotlin2") //error beacause it's a read only list => read-only lacks mutating methods



Conclusion :
Prefer vals to vars
It's better to specify type explicitly




3.Functions


a.Simple function
fun max(a:Int, b:Int):Int
{
	retrun if(a>b) a else b
}
OR
fun max(a:Int, b:Int):Int = if(a>b) a else b
OR // in case you're sure about the return type
fun max(a:Int, b:Int) = if(a>b) a else b

b. Function returning Unit ( Unit ~ void in Java)
fun diplayMax(a:Int, b:Int) : Unit
{ println (  max(a,b) )}

OR 
fun diplayMax(a:Int, b:Int) 
{ println (  max(a,b) )}


In Kotlin , you can define function everywhere

Top-level Function 		fun topLevel() =1
Member Function 		class A {
							fun member () =2
						}

Local Function 			fun other(){
						fun local() =3
						}

Exmaple : Calling a top-level Kotlin function from Java 

MyFile.kt
package intro
fun foo() = 0

Foo1.java
import MyFileKt.*

public class Foo1{
	public static void main (String[] args)
	{
		MyFileKT.foo();
	}
}


Foo2.java
import static MyFileKt.*

public class Foo1{
	public static void main (String[] args)
	{
		foo();
	}
}

OR 
Extensions.kt
@file:JvmName("Util") // to change the name of the class containt the top-level functions
package intro
fun foo() = 0

Foo3.java
import  Util
public class Foo1{
	public static void main (String[] args)
	{
		int i = Util.foo();
	}
}



c.Named & Default arguments in functions

Example :
println(listOf('a', 'b', 'c').joinToString(
    separator = "", prefix = "(", postfix = ")"))
Result : (abc)

Arguments : 
seperator ( default value = ",")
prefix (default value="")
postfix (default value="")

Example :
println(listOf(1,2,3).joinToString(postfix = "."))
Result : 1, 2, 3.

=> no need to specify all arguments 


fun displaySeparator(character : Char='*', size:Int=10)
{
	repeat(size){ print (character)}
}


displaySeparator('#',5) => Result : #####
displaySeparator('#') => Result : ##########
displaySeparator() => Result : **********
displaySeparator(size=5) => Result : ***** // you can specify the name of the arguments and their values

displaySeparator(3, '5') // compilation error : order of arguments doesn't match 
displaySeparator(size=3, character='5') => Result  : 555


( In Java we use overloads , several functions)

Example : Calling a function with default argument from Java

fun sum (a:Int=0, b:Int=0, c:Int=0)

from Java : sum(1,2,3);
If we want to be able to call the same function with different arguments 
@JvmOverloads
fun sum (a:Int=0, b:Int=0, c:Int=0)

from Java : sum(1);

=> Using JvmOverloads annotation , 4 overloaded functions are generated :
public static final int sum (int a, int b, int c)
public static final int sum (int a, int b)
public static final int sum (int a)
public static final int sum ()





II.Control structures

1. Conditionals : If & when ( Switch in Java)

val max = if (a>b) a else b  ( there is no : (a>b) a : b)

fun Test ( number:Int):String = when (number){
								1->"one"
								2->"two"
								3->"three"
								else -> "error"
							}
!!! no break !!!

fun Test2 ( number:Int):String = when (number){
								1,3,5,7,9->"even"
								2,4,6,8->"odd"
								else -> throw Exception ("1..9")
							}

fun Test3 ( x:Int, y:Int):String = when (setOf(x,y)){
								setOf(0,0)->"center"
								else -> throw Exception ("bad location")
							}

*Cheking types with when

when (pet) // OR when ( val pet= getMyPet())
{
	is Cat -> pet.meow()
	is Dof -> pet.woof()
}

!!! no need for casting the type after checking it like in java !!!


*Using when without an argument

fun updateWeather(degrees: Int)
{
	val (description,colour) = when {
	degrees<5 ->"cold" to BLUE
	degrees <23 -> "mild" to ORANGE
	else -> "hot" to RED
	}

}


=>  Pay attention , there is no need to change if to when,
you can use when pnly if needed ( depending on the use case)



2. Loops

a. while , do.. while are the same as Java
b. for loop
	val list = listOf("a","b","c")
	for ( s in list) // OR for (s:String in list) 
	{print(s)}
	=> Result : abc


*iterating over map
val map = mapOf(1 to "one", 2 to "two", 3 to "three")
for ( (key,value) in map)
{
	print ("$key : $value")
}

 *iterating with index
 val list = listOf("a","b","c")
 for ( (index,element)  in list.withIndex() )
 {
 	print (" $index : $element")
 }
 Result :
 0: a
 1: b
 2: c

*iterating over range
for (i in 1..9)
{
	print (i)
}
=> Result : 123456789
OR
for (i in 1 until 9) // 9 not included ( upperbound excluded)
{
	print (i)
}
=> Result : 12345678

for ( i in 9 downTo 1 step 2)
{ print (i) }
Result => 97531


*iterating over string 
for (ch in "abc") {
  print(ch ) 
}
Result : abc
for (ch in "abc") {
  print(ch + 1) 
}
Result : bcd // ch+1 means next character in alphabet


 in is used for cheks and ranges:
 Exmaple:
 1-for() i in 0..9) // iterating
 2- c in 'a'..'z' // check for belonging
 	// same as : ('a'<= c && c<='z')
 	k !in 'a'..'d' // NOT IN
 	if(element in list ) // Java : if(list.contains(element))
 3- when (c){
			 in '0'..'9' ->" number"
			 in 'a'..'z', in 'A'..'Z' -> "letter"
			 else -> "error"
			 }
4-

	 println("Kotlin" in "Java".."Scala")
	println("Kotlin" in setOf("Java", "Scala"))
	Result : true false
	// first line : string are compared by their alphabetic order ( charcter by character)

	"ball" in "a" .."k" // "a".compareTo("ball")<=0 && "ball".compareTo("k")<=0


	"ball" in "a" .."k" // true : because 'b' is between 'a'..'k'
	"zoo" in "a".."k" // false : because 'z' isNOTbetween 'a'..'k'
5- Comparing dates
	class MyDate: Comparable<MyDate>

	if (myDate in startDate..endDate) //no need for compareTO!



3. Exceptions
KotlinFile.kt 
@Throws (IOException::calss)
fun bar(){ throw IOException() }

JavaFile.java
try{
	kotlinFile.bar()
}catch ( IOException e){ print(" caught !")}

Example Control Structure:
Implement the function that checks whether a string is a valid identifier. A valid identifier is a non-empty string that starts with a letter or underscore and consists of only letters, digits and underscores.

fun isValidIdentifier(s: String): Boolean {
    if (s=="" || (s !in "a".."z" && s !in "A".."Z" && s.compareTo("_")<0))
    return false
   for( k in s)
    {
        if ( k !in 'a'..'z' && k !in 'A'..'Z' && k !in '0'..'9' && k.compareTo('_')<0 )
        return false
    }
    return true
}

fun main(args: Array<String>) {
    println(isValidIdentifier("name"))   // true
    println(isValidIdentifier("_name"))  // true
    println(isValidIdentifier("_12"))    // true
    println(isValidIdentifier(""))       // false
    println(isValidIdentifier("012"))    // false
    println(isValidIdentifier("no$"))    // false
}

III.Extensions
 One of the best features of Kotlin, their main purpose is to keep your classes and interfaces APIs minimal.



1. Extension Functions
StringExtentionsFile.kt
fun String.lastChar() = get(length-1)
OtherFile.kt
import com.example.util.*
val x:Char ="abc".lastChar() // x="c"

Calling from Java :
JavaFile.java
import static StringExtensionsFileKt.lastChar;
char x = lastChar("abc");

2. Extensions from Standard Library (Kotlin SL => Java SL + extensions)


val set = hashSetOf(1,7,53)
val list = arrayListOf(1,7,53)
val map = hashMapOf(1 to "one", 7 to "seven", 53 to "fifty-three")

println(set.javaClass) // class java .util.HashSet (set.javaClass <=> getCalss() in java)

*Kotlin Extensions (regular functions):
joinToString()// used with string
getOrNull() // used with array
withIndex() // used with collections
until // 1 until 10 OR 1.until(10)
to // "hot" to RED OR "hot".to("RED") // pair of values 
 	// val pair:Pair<Char,Double> = 'a' to 1.0
.... a lot of other extensions

*Kotlin Extension on String
val q = """ text,
			no text"""
println(q)
Result: text
			no text
val q = """ text,
no text""".trimMargin()
println(q)
Result: text
			no text
.trimMargin()
.trimIndent()

-Regular Expressions
	val regex = "\\d{2}\\.\\d{2}\\.\\d{4}".toRegex()
	// OR val regex ="""\d{2}\.\d{2}\.\d{4}""".toRegex()
	regex.matches("15.02.2016") // true
	regex.matches("15.02.16") // false
- Conversion to numbers
	"123".toInt() // 123
	"1e-10".toDouble() // 0.00..1
	"vv".toInt() // NumberFormatException
- Extension function eq ( checks wethter receiver equal argument,
display OK or Error)
	fun getAnswer() = 42
	getAnswer() eq 42 // OK
	getAnswer() eq 43 // Error: 42 != 43

3.Calling Extensions

 fun String.get(index:Int) ='*'
 fun main()
 {
 	println( "abc".get(1))
 }
Result : b Member always wins

